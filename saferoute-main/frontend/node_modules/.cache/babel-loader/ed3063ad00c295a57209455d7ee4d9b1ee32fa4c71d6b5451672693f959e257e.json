{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport api from '../../services/api';\n\n// Async thunks for route operations\nexport const calculateRoute = createAsyncThunk('routes/calculateRoute', async (routeData, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await api.post('/routes/calculate', routeData);\n    return response.data;\n  } catch (error) {\n    var _error$response, _error$response$data;\n    return rejectWithValue(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Failed to calculate route');\n  }\n});\nexport const fetchRouteHistory = createAsyncThunk('routes/fetchHistory', async ({\n  page = 1,\n  limit = 20,\n  routeType\n} = {}, {\n  rejectWithValue\n}) => {\n  try {\n    const params = new URLSearchParams({\n      page,\n      limit\n    });\n    if (routeType) params.append('routeType', routeType);\n    const response = await api.get(`/routes/history?${params}`);\n    return response.data;\n  } catch (error) {\n    var _error$response2, _error$response2$data;\n    return rejectWithValue(((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || 'Failed to fetch route history');\n  }\n});\nexport const fetchSavedRoutes = createAsyncThunk('routes/fetchSaved', async (_, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await api.get('/routes/saved');\n    return response.data;\n  } catch (error) {\n    var _error$response3, _error$response3$data;\n    return rejectWithValue(((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.message) || 'Failed to fetch saved routes');\n  }\n});\nexport const saveRoute = createAsyncThunk('routes/saveRoute', async ({\n  routeId,\n  name\n}, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await api.put(`/routes/${routeId}/save`, {\n      name\n    });\n    return response.data;\n  } catch (error) {\n    var _error$response4, _error$response4$data;\n    return rejectWithValue(((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : (_error$response4$data = _error$response4.data) === null || _error$response4$data === void 0 ? void 0 : _error$response4$data.message) || 'Failed to save route');\n  }\n});\nexport const fetchPopularRoutes = createAsyncThunk('routes/fetchPopular', async ({\n  lat,\n  lng,\n  radius = 10\n}, {\n  rejectWithValue\n}) => {\n  try {\n    const response = await api.get(`/routes/popular?lat=${lat}&lng=${lng}&radius=${radius}`);\n    return response.data;\n  } catch (error) {\n    var _error$response5, _error$response5$data;\n    return rejectWithValue(((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : (_error$response5$data = _error$response5.data) === null || _error$response5$data === void 0 ? void 0 : _error$response5$data.message) || 'Failed to fetch popular routes');\n  }\n});\nconst initialState = {\n  currentRoutes: null,\n  // { fastest: Route, safest: Route }\n  routeHistory: [],\n  savedRoutes: [],\n  popularRoutes: [],\n  nearbyRoutes: [],\n  currentRouteType: 'fastest',\n  isCalculating: false,\n  isLoading: false,\n  error: null,\n  calculationMetrics: null,\n  pagination: {\n    page: 1,\n    limit: 20,\n    total: 0,\n    pages: 0\n  }\n};\nconst routeSlice = createSlice({\n  name: 'routes',\n  initialState,\n  reducers: {\n    setCurrentRouteType: (state, action) => {\n      state.currentRouteType = action.payload;\n    },\n    clearCurrentRoutes: state => {\n      state.currentRoutes = null;\n      state.calculationMetrics = null;\n      state.error = null;\n    },\n    clearError: state => {\n      state.error = null;\n    },\n    updateRouteInHistory: (state, action) => {\n      const {\n        routeId,\n        updates\n      } = action.payload;\n      const routeIndex = state.routeHistory.findIndex(route => route._id === routeId);\n      if (routeIndex !== -1) {\n        state.routeHistory[routeIndex] = {\n          ...state.routeHistory[routeIndex],\n          ...updates\n        };\n      }\n    },\n    addRouteToSaved: (state, action) => {\n      const route = action.payload;\n      const existingIndex = state.savedRoutes.findIndex(r => r._id === route._id);\n      if (existingIndex === -1) {\n        state.savedRoutes.unshift(route);\n      }\n    },\n    removeRouteFromSaved: (state, action) => {\n      const routeId = action.payload;\n      state.savedRoutes = state.savedRoutes.filter(route => route._id !== routeId);\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Calculate Route\n    .addCase(calculateRoute.pending, state => {\n      state.isCalculating = true;\n      state.error = null;\n    }).addCase(calculateRoute.fulfilled, (state, action) => {\n      state.isCalculating = false;\n      state.currentRoutes = action.payload.routes;\n      state.calculationMetrics = {\n        calculationTime: action.payload.calculationTime,\n        unsafeZonesCount: action.payload.unsafeZonesCount,\n        activeHazardsCount: action.payload.activeHazardsCount,\n        routeId: action.payload.routeId\n      };\n      state.error = null;\n    }).addCase(calculateRoute.rejected, (state, action) => {\n      state.isCalculating = false;\n      state.error = action.payload;\n    })\n\n    // Fetch Route History\n    .addCase(fetchRouteHistory.pending, state => {\n      state.isLoading = true;\n      state.error = null;\n    }).addCase(fetchRouteHistory.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.routeHistory = action.payload.routes;\n      state.pagination = action.payload.pagination;\n      state.error = null;\n    }).addCase(fetchRouteHistory.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload;\n    })\n\n    // Fetch Saved Routes\n    .addCase(fetchSavedRoutes.pending, state => {\n      state.isLoading = true;\n    }).addCase(fetchSavedRoutes.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.savedRoutes = action.payload.routes;\n    }).addCase(fetchSavedRoutes.rejected, (state, action) => {\n      state.isLoading = false;\n      state.error = action.payload;\n    })\n\n    // Save Route\n    .addCase(saveRoute.fulfilled, (state, action) => {\n      const {\n        route\n      } = action.payload;\n      // Update the route in history if it exists\n      const historyIndex = state.routeHistory.findIndex(r => r._id === route.id);\n      if (historyIndex !== -1) {\n        state.routeHistory[historyIndex].isSaved = route.isSaved;\n        state.routeHistory[historyIndex].name = route.name;\n      }\n\n      // Add to or remove from saved routes\n      if (route.isSaved) {\n        const existingIndex = state.savedRoutes.findIndex(r => r._id === route.id);\n        if (existingIndex === -1) {\n          // Add to saved routes (you'll need the full route object from history)\n          const fullRoute = state.routeHistory.find(r => r._id === route.id);\n          if (fullRoute) {\n            state.savedRoutes.unshift(fullRoute);\n          }\n        }\n      } else {\n        state.savedRoutes = state.savedRoutes.filter(r => r._id !== route.id);\n      }\n    })\n\n    // Fetch Popular Routes\n    .addCase(fetchPopularRoutes.fulfilled, (state, action) => {\n      state.popularRoutes = action.payload.popularRoutes;\n      state.nearbyRoutes = action.payload.nearbyRoutes;\n    });\n  }\n});\nexport const {\n  setCurrentRouteType,\n  clearCurrentRoutes,\n  clearError,\n  updateRouteInHistory,\n  addRouteToSaved,\n  removeRouteFromSaved\n} = routeSlice.actions;\nexport default routeSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","api","calculateRoute","routeData","rejectWithValue","response","post","data","error","_error$response","_error$response$data","message","fetchRouteHistory","page","limit","routeType","params","URLSearchParams","append","get","_error$response2","_error$response2$data","fetchSavedRoutes","_","_error$response3","_error$response3$data","saveRoute","routeId","name","put","_error$response4","_error$response4$data","fetchPopularRoutes","lat","lng","radius","_error$response5","_error$response5$data","initialState","currentRoutes","routeHistory","savedRoutes","popularRoutes","nearbyRoutes","currentRouteType","isCalculating","isLoading","calculationMetrics","pagination","total","pages","routeSlice","reducers","setCurrentRouteType","state","action","payload","clearCurrentRoutes","clearError","updateRouteInHistory","updates","routeIndex","findIndex","route","_id","addRouteToSaved","existingIndex","r","unshift","removeRouteFromSaved","filter","extraReducers","builder","addCase","pending","fulfilled","routes","calculationTime","unsafeZonesCount","activeHazardsCount","rejected","historyIndex","id","isSaved","fullRoute","find","actions","reducer"],"sources":["C:/Users/mathew/Downloads/saferoute-main/saferoute-main/frontend/src/store/slices/routeSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\r\nimport api from '../../services/api';\r\n\r\n// Async thunks for route operations\r\nexport const calculateRoute = createAsyncThunk(\r\n  'routes/calculateRoute',\r\n  async (routeData, { rejectWithValue }) => {\r\n    try {\r\n      const response = await api.post('/routes/calculate', routeData);\r\n      return response.data;\r\n    } catch (error) {\r\n      return rejectWithValue(error.response?.data?.message || 'Failed to calculate route');\r\n    }\r\n  }\r\n);\r\n\r\nexport const fetchRouteHistory = createAsyncThunk(\r\n  'routes/fetchHistory',\r\n  async ({ page = 1, limit = 20, routeType } = {}, { rejectWithValue }) => {\r\n    try {\r\n      const params = new URLSearchParams({ page, limit });\r\n      if (routeType) params.append('routeType', routeType);\r\n      \r\n      const response = await api.get(`/routes/history?${params}`);\r\n      return response.data;\r\n    } catch (error) {\r\n      return rejectWithValue(error.response?.data?.message || 'Failed to fetch route history');\r\n    }\r\n  }\r\n);\r\n\r\nexport const fetchSavedRoutes = createAsyncThunk(\r\n  'routes/fetchSaved',\r\n  async (_, { rejectWithValue }) => {\r\n    try {\r\n      const response = await api.get('/routes/saved');\r\n      return response.data;\r\n    } catch (error) {\r\n      return rejectWithValue(error.response?.data?.message || 'Failed to fetch saved routes');\r\n    }\r\n  }\r\n);\r\n\r\nexport const saveRoute = createAsyncThunk(\r\n  'routes/saveRoute',\r\n  async ({ routeId, name }, { rejectWithValue }) => {\r\n    try {\r\n      const response = await api.put(`/routes/${routeId}/save`, { name });\r\n      return response.data;\r\n    } catch (error) {\r\n      return rejectWithValue(error.response?.data?.message || 'Failed to save route');\r\n    }\r\n  }\r\n);\r\n\r\nexport const fetchPopularRoutes = createAsyncThunk(\r\n  'routes/fetchPopular',\r\n  async ({ lat, lng, radius = 10 }, { rejectWithValue }) => {\r\n    try {\r\n      const response = await api.get(`/routes/popular?lat=${lat}&lng=${lng}&radius=${radius}`);\r\n      return response.data;\r\n    } catch (error) {\r\n      return rejectWithValue(error.response?.data?.message || 'Failed to fetch popular routes');\r\n    }\r\n  }\r\n);\r\n\r\nconst initialState = {\r\n  currentRoutes: null, // { fastest: Route, safest: Route }\r\n  routeHistory: [],\r\n  savedRoutes: [],\r\n  popularRoutes: [],\r\n  nearbyRoutes: [],\r\n  currentRouteType: 'fastest',\r\n  isCalculating: false,\r\n  isLoading: false,\r\n  error: null,\r\n  calculationMetrics: null,\r\n  pagination: {\r\n    page: 1,\r\n    limit: 20,\r\n    total: 0,\r\n    pages: 0\r\n  }\r\n};\r\n\r\nconst routeSlice = createSlice({\r\n  name: 'routes',\r\n  initialState,\r\n  reducers: {\r\n    setCurrentRouteType: (state, action) => {\r\n      state.currentRouteType = action.payload;\r\n    },\r\n    clearCurrentRoutes: (state) => {\r\n      state.currentRoutes = null;\r\n      state.calculationMetrics = null;\r\n      state.error = null;\r\n    },\r\n    clearError: (state) => {\r\n      state.error = null;\r\n    },\r\n    updateRouteInHistory: (state, action) => {\r\n      const { routeId, updates } = action.payload;\r\n      const routeIndex = state.routeHistory.findIndex(route => route._id === routeId);\r\n      if (routeIndex !== -1) {\r\n        state.routeHistory[routeIndex] = { ...state.routeHistory[routeIndex], ...updates };\r\n      }\r\n    },\r\n    addRouteToSaved: (state, action) => {\r\n      const route = action.payload;\r\n      const existingIndex = state.savedRoutes.findIndex(r => r._id === route._id);\r\n      if (existingIndex === -1) {\r\n        state.savedRoutes.unshift(route);\r\n      }\r\n    },\r\n    removeRouteFromSaved: (state, action) => {\r\n      const routeId = action.payload;\r\n      state.savedRoutes = state.savedRoutes.filter(route => route._id !== routeId);\r\n    }\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Calculate Route\r\n      .addCase(calculateRoute.pending, (state) => {\r\n        state.isCalculating = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(calculateRoute.fulfilled, (state, action) => {\r\n        state.isCalculating = false;\r\n        state.currentRoutes = action.payload.routes;\r\n        state.calculationMetrics = {\r\n          calculationTime: action.payload.calculationTime,\r\n          unsafeZonesCount: action.payload.unsafeZonesCount,\r\n          activeHazardsCount: action.payload.activeHazardsCount,\r\n          routeId: action.payload.routeId\r\n        };\r\n        state.error = null;\r\n      })\r\n      .addCase(calculateRoute.rejected, (state, action) => {\r\n        state.isCalculating = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Fetch Route History\r\n      .addCase(fetchRouteHistory.pending, (state) => {\r\n        state.isLoading = true;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchRouteHistory.fulfilled, (state, action) => {\r\n        state.isLoading = false;\r\n        state.routeHistory = action.payload.routes;\r\n        state.pagination = action.payload.pagination;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchRouteHistory.rejected, (state, action) => {\r\n        state.isLoading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Fetch Saved Routes\r\n      .addCase(fetchSavedRoutes.pending, (state) => {\r\n        state.isLoading = true;\r\n      })\r\n      .addCase(fetchSavedRoutes.fulfilled, (state, action) => {\r\n        state.isLoading = false;\r\n        state.savedRoutes = action.payload.routes;\r\n      })\r\n      .addCase(fetchSavedRoutes.rejected, (state, action) => {\r\n        state.isLoading = false;\r\n        state.error = action.payload;\r\n      })\r\n      \r\n      // Save Route\r\n      .addCase(saveRoute.fulfilled, (state, action) => {\r\n        const { route } = action.payload;\r\n        // Update the route in history if it exists\r\n        const historyIndex = state.routeHistory.findIndex(r => r._id === route.id);\r\n        if (historyIndex !== -1) {\r\n          state.routeHistory[historyIndex].isSaved = route.isSaved;\r\n          state.routeHistory[historyIndex].name = route.name;\r\n        }\r\n        \r\n        // Add to or remove from saved routes\r\n        if (route.isSaved) {\r\n          const existingIndex = state.savedRoutes.findIndex(r => r._id === route.id);\r\n          if (existingIndex === -1) {\r\n            // Add to saved routes (you'll need the full route object from history)\r\n            const fullRoute = state.routeHistory.find(r => r._id === route.id);\r\n            if (fullRoute) {\r\n              state.savedRoutes.unshift(fullRoute);\r\n            }\r\n          }\r\n        } else {\r\n          state.savedRoutes = state.savedRoutes.filter(r => r._id !== route.id);\r\n        }\r\n      })\r\n      \r\n      // Fetch Popular Routes\r\n      .addCase(fetchPopularRoutes.fulfilled, (state, action) => {\r\n        state.popularRoutes = action.payload.popularRoutes;\r\n        state.nearbyRoutes = action.payload.nearbyRoutes;\r\n      });\r\n  },\r\n});\r\n\r\nexport const {\r\n  setCurrentRouteType,\r\n  clearCurrentRoutes,\r\n  clearError,\r\n  updateRouteInHistory,\r\n  addRouteToSaved,\r\n  removeRouteFromSaved\r\n} = routeSlice.actions;\r\n\r\nexport default routeSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}